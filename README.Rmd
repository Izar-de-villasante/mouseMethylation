---
title: Analysis of human methylation data with R
output: github_document
---

## Description

This document describes the workflow for analyzing of human methylation array data using R and mainly three Bioconductor packages: `minfi`, `limma`, and `DMRcate`. It includes the import and preprocessing of the data, followed by differential methylation analysis to find and annotate differentially methylated positions (DMPs) and regions (DMRs).

> __Note__: This document is the markdown version of the [human_methylation.R](https://github.com/raulsanzr/FDP/blob/main/R/human_methylation.R) script.

## Required packages

```{r message=F, warning=F}
library(minfi)        # BiocManager::install("minfi")
library(limma)        # BiocManager::install("limma")
library(DMRcate)      # BiocManager::install("DMRcate")
library(maxprobes)    # remotes::install_github("markgene/maxprobes")
library(readxl)       # install.packages("readxl")
library(dplyr)        # install.packages("dplyr")
library(ggplot2)      # install.packages("ggplot2")
library(ggrepel)      # install.packages("ggrepel")
library(ggfortify)    # install.packages("ggfortify")
library(gplots)       # install.packages("gplots")
library(RColorBrewer) # install.packages("RColorBrewer")
```

## Loading the data

### Methylation data

The data for this study was produced by the _Infinium MethylationEPIC BeadChip_ array designed by Illumina in 2016. This microarray quantifies the methylation levels in more than 850,000 different CpG sites of the human genome. However, this workflow can also be used with data obtained from the previous version of the chip (_Infinium HumanMethylation450 BeadChip_) by changing a couple of parameters.

The following function from `minfi` can read all the IDAT files produced by the array and store this data in an RGChannelSet object with its corresponding annotation.

```{r warning=F}
rgSet <- read.metharray.exp("data/human/") # folder where the IDAT files are placed
```

### Metadata

The metadata is a file that includes relevant information about the samples that will be useful later to group them. 

```{r}
metadata <- as.data.frame(read_excel("data/human/PIK3CA_samples_SC.xlsx"))

# renaming variables and removing redundant information
names(metadata)[1:10] <- c("Sample", "Organism", "Tissue", "Type", "Condition", "Preservation", 
                           "DNA_quantity", "EPIC_ID", "EPIC_position", "EPIC_barcode")
metadata$CellType <- paste(metadata$CellType1, metadata$CellType2, sep="_" )
metadata$CellType <- gsub("thelial","", gsub("_NA","", as.character(metadata$CellType)))
metadata$Condition <- gsub("pik3ca ","", as.character(metadata$Condition))
metadata$Type <- gsub("Vascular malformation", "Mutation", metadata$Type)
metadata <- metadata[,-c(2, 3, 6, 8, 9, 12, 13, 14)]

head(metadata)
```

## Quality control

### QC report

`minfi` incorporates a function that generates a quality control report from the raw data in PDF format. It includes plots representing the distribution of the detected methylation intensities for each sample and at each detection step.

```{r eval=F}
qcReport(rgSet, pdf="results/human/qcReport.pdf", sampGroups=metadata$Condition, sampNames=metadata$Sample)
```

### Detection p-values

Detection p-values provide a measure of how likely the signal of a probe is different from the background. The next barplot shows the mean of the detection p-values for every sample with respect to the cutoff ($p=0.01$).

```{r det_p, message=F}
# detection p-values
p_values <- detectionP(rgSet, type="m+u")

# mean detection p-values
mean_p <- data.frame(p_values=colMeans(p_values), Sample=metadata$Sample)

# plotting the mean detection p-values
ggplot(mean_p, aes(x=Sample, y=p_values, fill=p_values))+
  geom_col()+
  geom_hline(yintercept=0.01, linetype="dashed", color="red")+
  ggtitle("Mean detection p-value per sample")+
  theme_bw()+
  theme(legend.position="none", axis.title.x=element_blank(), axis.title.y=element_blank(), 
        axis.text.x=element_text(angle=30, vjust=1, hjust=1))
```

## Preprocessing

### Normalization

There are some different options to normalize the data with `minfi`. Which one to use will always depend on the characteristics of the data to analyze.

- `preprocessRaw`: No normalization.
- `preprocessIllumina`: Illuminaâ€™s GenomeStudio preprocessing.
- `preprocessSWAN`: Subset-quantile within array normalization.
- `preprocessQuantile`: Quantile normalization.
- `preprocessNoob`: Normal-exponential out-of-band background correction.
- `preprocessFunnorm`: Functional normalization.

> __Note__: Find more documentation about the different preprocessing functions [here](https://www.bioconductor.org/help/course-materials/2015/BioC2015/methylation450k.html#preprocessing-and-normalization).

```{r message=F}
mSet <- preprocessNoob(rgSet)
```

### Removing low quality probes

Probes with a detection p-value above the cutoff ($p \ge 0.01$) are not significant and may not be reliable enough. It is recommended to remove those sites to avoid biases.

```{r}
keep <- rowSums(p_values < 0.01) == ncol(mSet)
mSet <- mSet[keep,]
```

### Removing probes with known SNPs

The function `dropLociWithSnps` allows discarding those probes known to have a single nucleotide polymorphism.

```{r warning=F}
gmSet <- dropLociWithSnps(mapToGenome(mSet))
```

### Removing cross reactive probes

Cross-reactive probes are sites found to map at different genome locations (which usually involves an autosomal and a sex chromosome). In the function `xreactive_probes` there are collected and annotated those probes found in [Pidsley et al.](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-016-1066-1) and [McCartney et al.](https://www.sciencedirect.com/science/article/pii/S221359601630071X) studies.

```{r}
xreactive_probes <- xreactive_probes(array_type="EPIC")
keep <- !(featureNames(gmSet) %in% xreactive_probes)
gmSet <- gmSet[keep,]
```

### Removing sex chromosomes probes

CpG sites present at the sexual chromosomes (chrX and chrY) can be differently methylated in males and females for many other factors not included in the analysis. In this case, those probes should be removed because the gender of the individuals is not a variable under study. However, if we were interested in studying the differences in methylation between males and females, we should keep those sites.

```{r warning=F}
ann <- getAnnotation(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)
keep <- !(featureNames(gmSet) %in% ann$Name[ann$chr %in% c("chrX","chrY")])
gmSet <- gmSet[keep,]
```

### Obtaining the beta values

The beta-value is a measurement of the methylation at the CpG site level that ranges between 0 and 1, representing a completely unmethylated or methylated site, respectively. It can be calculated using the following formula:

$\beta=\frac{M}{M+U+100}$

```{r}
beta_values <- getBeta(gmSet)
colnames(beta_values) <- metadata$Sample
head(beta_values[,1:6])
```

## Principal Component Analysis

Principal Component Analysis (PCA) is a dimensionality reduction technique used to reduce a data set with many variables into a few called principal components. Those are variables built by the combination of the initial ones that aim to explain as much variance as possible in order to be able to represent the data in two (or three) dimensions.

### PCA on the most variable sites

Selecting the sites with higher variation across the samples is an approach to reduce the number of inputs and speed up the PCA calculation. However, the number of selected sites should be large enough not to reduce the performance of the PCA.

```{r}
# selecting the top 100 most variable CpGs
sdv <- apply(beta_values,1, sd)
keep <- names(head(sort(sdv,decreasing=T), 100))
beta_top100 <- beta_values[keep,]

# PCA calculation
pca_res <- prcomp(t(beta_top100), scale=T, center=T) # ! the matrix needs to transpose
```

#### Plotting by condition

```{r pca_cond}
autoplot(pca_res, x=1, y=2,data=metadata, colour="Condition")+
  geom_text_repel(aes(label=Sample, color=Condition),hjust=-0.1, vjust=0, show.legend=F, size=3.5)+
  xlim(c(-0.5,0.3)) +
  theme_bw()
```

#### Plotting by cell type

```{r pca_cell}
autoplot(pca_res, x=1, y=2,data=metadata, colour="CellType", shape = "Type")+
  geom_text_repel(aes(label=Sample, color=CellType),hjust=-0.1, vjust=0, show.legend=F, size=3.5)+
  scale_color_brewer(palette="Set1")+ 
  labs(colour="Cell Type") + xlim(c(-0.5,0.3)) +
  theme_bw()
```

## Differential methylation analysis

### Differentially Methylated Positions

The differentially methylated positions (DMPs) are individual CpG sites showing statistically different methylation levels across the study samples.

#### Finding DMPs

Those positions can be detected using `limma` to build linear models that look for significant differences in the beta values at single probes. In this case, all pairwise comparisons will be performed for the samples grouped by condition.

```{r results = 'hide'}
# building the design matrix
mutation <- factor(metadata$Condition)
designMat <- model.matrix(~0+mutation, data=metadata)
colnames(designMat) <- levels(mutation)

# building the contrast matrix
contMat <- makeContrasts(Control-E542K, 
                         Control-E545K, 
                         Control-H1047R, 
                         E542K-E545K, 
                         E542K-H1047R, 
                         H1047R-E545K, levels=designMat)

# fitting linear model with limma
fit <- lmFit(beta_values, designMat)
fit2 <- contrasts.fit(fit, contMat)
fit2 <- eBayes(fit2)

summary(decideTests(fit2, p.value=0.01))
```

> __Note__: DMPs can be either hypomethylated (loss of methylation) or hypermethylated (gain of methylation) sites.

|                   | Hypomethylated | Hypermethylated | TOTAL |
| :---------------- | :------------: | :-------------: | :---: |
| Control vs E542K  | 7              | 1               | 8     |
| Control vs E545K  | 12             | 0               | 12    |
| Control vs H1047R | 17             | 0               | 17    |
| E542K vs E545K    | 3              | 0               | 3     |
| E542K vs H1047R   | 1              | 1               | 2     |
| H1047R vs E545K   | 2              | 0               | 2     |

#### Annotating the DMPs

In the previous step, we obtained differently methylated sites, but annotating them will provide more specific information relative to where they are located in the genome.

```{r}
contrasts <- colnames(contMat)

# matching beta values with annotation by the probe names
annEPICSub <- ann[match(rownames(beta_values),ann$Name), c(1:4,12:19,22:ncol(ann))]

DMP.list <- data.frame() # df to store the DMPs
cg <- list() # list to store the names of significant probes

for (i in 1:length(contrasts)){
  # extract the significant DMPs and annotate
  DMP <- topTable(fit2, num=Inf, coef=i, genelist=annEPICSub, p.value=0.01)
  DMP$Contrast <- contrasts[i]
  # saving the results
  DMP.list <- rbind(DMP.list, DMP)
  cg[[i]] <- row.names(DMP)
}

# write.csv(DMP.list, "results/human/DMP_list.csv")

### merging all the DMP's
DMP_ann <- DMP.list

# classifying DMPs according to its change in methylation
DMP_ann$Type <- "Hypermethylated"
DMP_ann$Type[which(DMP_ann$logFC > 0)] <- "Hypomethylated"

# gene feature annotation
DMP_ann$UCSC_RefGene_Group[which(DMP_ann$UCSC_RefGene_Group == "")] <- "."
DMP_ann$UCSC_RefGene_Group_short <- unlist(lapply(strsplit(DMP_ann$UCSC_RefGene_Group,";"),'[[', 1))
```

#### DMPs by CpG islands

```{r dmp_cgi, warning=F}
DMP_annCGI <- DMP_ann[, c("Contrast", "Relation_to_Island", "Type")]

ggplot(DMP_annCGI, aes(Contrast, fill=Relation_to_Island))+
  facet_wrap(.~Type, scales="free_x")+
  geom_histogram(stat="count", width=0.75)+
  theme_bw()+ 
  theme(axis.text.x=element_text(angle=30, hjust=1, size=8))+
  ylab("Number of DMPs")+ 
  xlab("")
```

#### DMPs by gene elements

```{r dmp_gene, warning=F}
DMP_Gene_Group <- DMP_ann[,c("Contrast","UCSC_RefGene_Group_short", "Type")]

ggplot(DMP_Gene_Group, aes(Contrast, fill=UCSC_RefGene_Group_short))+
  facet_wrap(.~Type, scales="free_x")+
  geom_histogram(stat="count", width=0.75)+ 
  theme_bw()+ 
  scale_fill_brewer(palette="Set2")+
  theme(axis.text.x=element_text(angle=30, hjust=1, size=8))+
  ylab("Number of DMPs")+
  xlab("")+ 
  labs(fill="UCSC_RefGene")
```

#### Heatmap of DMPs

```{r dmp_heatmap}
# joining the DMPs with their beta values
DMP_beta <- data.frame(beta_values[unlist(cg), ])
colnames(DMP_beta) <- paste0(metadata$Sample,"_",metadata$Condition)

colors <- colorRampPalette(c("royalblue", "white", "red"))(n=100) # range of colors
heatmap.2(as.matrix(t(unique(DMP_beta))), trace="none", density.inf="none", 
          margins=c(7,10), col=colors, cexRow = 1, lwid = c(5,15), lhei = c(5,15))
```

### Differentially Methylated Regions

Differentially methylated regions (DMRs) rely on the same principle as DMPs. However, instead of looking at single sites, the difference in methylation is compared at regions formed by two or more CpGs.

#### Finding and annotating DMRs

`DMRcate` is a package that allows finding and annotating DMRs from the beta values given a design and a contrast matrix. It generates a GenomicRanges object containing the coordinates of the DMR and some statistics that support the finding.

```{r warning=F, message=F}
DMR.list <- data.frame()
for(i in 1:length(contrasts)){
  # annotating the CpG's for each contrast + finding significant CpG's
  myAnnotation <- cpg.annotate(object=beta_values, datatype="array", what="Beta",contrasts=T,  
                               design=designMat, cont.matrix=contMat, analysis.type="differential",
                               coef=gsub("_", " - ", as.character(contrasts[i])), arraytype="EPIC")
  
  if(sum(myAnnotation@ranges@elementMetadata@listData$is.sig)!=0){ # if there are significant CpG's
    # test for DMRs
    DMR_raw <- dmrcate(myAnnotation, lambda=1000, C=2)
    # extract genomic ranges
    results.ranges <- extractRanges(DMR_raw)
    # saving the results
    DMR <- data.frame(Contrast=contrasts[i], results.ranges)
    DMR.list <- rbind(DMR.list, DMR)
  }
}

DMR.list$overlapping.genes <- unlist(DMR.list$overlapping.genes)
# write.csv(DMR.list, "results/human/DMR_list.csv")

# showing the found DMRs for the first contrast: control vs E542K
head(DMR.list[,c(2:7,14)], 5)
```

#### Plotting DMRs

This package also includes the function `DMR.plot` to plot the found DMRs based on `Gviz` representations by tracks.

```{r dmr, warning=F, message=F}
pal <- brewer.pal(8, "Dark2") # palette

# to colour by mutation (condition)
groups <- pal[1:length(unique(metadata$Condition))]
names(groups) <- levels(factor(metadata$Condition))
cols <- groups[as.character(factor(metadata$Condition))]

# is needed to convert the data frame into a genomic ranges object
DMR.GR <- makeGRangesFromDataFrame(DMR.list)

DMR.plot(ranges=DMR.GR, dmr=10, CpGs=beta_values, phen.col=cols, what="Beta", arraytype="EPIC", 
         genome="hg19")
```

> __Note__: Other desired regions of the genome can be plotted using the [plot_DMR.R](https://github.com/raulsanzr/FDP/blob/main/R/plot_DMR.R) script.

## Session information

```{r echo=F}
sessionInfo()
```
