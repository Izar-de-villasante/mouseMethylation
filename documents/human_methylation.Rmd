---
title: Analysis of human methylation data with R
output: github_document
---

## Description

This document contains the workflow for the analysis of human methylation array data using R and mainly three Bioconductor packages: `minfi`, `limma`, and `DMRcate`.

It comprises a preprocessing step to normalize and filter the raw data that could lead to biases and a differential methylation analysis to identify, annotate and represent DMPs and DMRs.

> __Note__: This document is generated from [human_methylation.Rmd](https://github.com/raulsanzr/FDP/blob/main/scripts/human_methylation.Rmd), which is adapted from [human_methylation.R](https://github.com/raulsanzr/FDP/blob/main/scripts/human_methylation.R).

## Required packages

```{r message=F, warning=F}
library(minfi)
library(limma)
library(DMRcate)
library(maxprobes)
library(readxl)
library(dplyr)
library(ggplot2)
library(ggrepel)
library(ggfortify)
library(gplots)
library(RColorBrewer)
```

## Loading the data

### Methylation data

The data for this study was produced by the Infinium MethylationEPIC BeadChip array designed by Illumina in 2016, which quantifies the methylation levels in more than 850,000 different CpG sites of the human genome.

The following function from `minfi` can to read all the IDAT files produced by the array and stores this data in an RGChannelSet object together with its corresponding annotation.

```{r warning=F}
rgSet <- read.metharray.exp("data/human/")
class(rgSet)[1]
```

### Metadata

```{r}
metadata <- as.data.frame(read_excel("data/human/PIK3CA_samples_SC.xlsx"))

# renaming and removing redundant information
names(metadata)[1:10] <- c("Sample", "Organism", "Tissue", "Type", "Condition", "Preservation", 
                           "DNA_quantity", "EPIC_ID", "EPIC_position", "EPIC_barcode")
metadata$CellType <- paste(metadata$CellType1, metadata$CellType2, sep="_" )
metadata$CellType <- gsub("thelial","", gsub("_NA","", as.character(metadata$CellType)))
metadata$Condition <- gsub("pik3ca ","", as.character(metadata$Condition))
metadata$Type <- gsub("Vascular malformation", "Mutation", metadata$Type)
metadata <- metadata[,-c(2, 3, 6, 8, 9, 12, 13, 14)]

head(metadata)
```

## Quality control

### QC report

`minfi` incorporates a function that generates a quality control report of the raw data in PDF format. This document includes several plots to assess the distribution of the detected methylation intensities.

```{r eval=F}
# quality control report for the raw data
qcReport(rgSet, pdf="results/human/qcReport.pdf", sampGroups=metadata$Condition, sampNames=metadata$Sample)
```

### Detection p-values

Detection p-values provide a measure of how likely the signal of a probe is different from the background. The next plot includes the mean of the detection p-values for every sample with respect to the cutoff (p=0.01).

```{r det_p, message=F}
# detection p-values
p_values <- detectionP(rgSet, type = "m+u")

# mean detection p-values
mean_p <- data.frame(p_values=colMeans(p_values), Sample=metadata$Sample)

# plotting the mean detection p-values
ggplot(mean_p, aes(x=Sample, y=p_values, fill=p_values))+
  geom_col()+
  geom_hline(yintercept=0.01, linetype="dashed", color="red")+
  ggtitle("Mean detection p-value per sample")+
  theme_bw()+
  theme(legend.position="none", axis.title.x=element_blank(), axis.title.y=element_blank(), 
        axis.text.x=element_text(angle=30, vjust=1, hjust=1))
```

## Preprocessing

### Normalization

There are some different options in `minfi` to perform normalization. Which one to use will always depend on the characteristics of the data to analyze.

- `preprocessRaw`: No normalization.
- `preprocessIllumina`: Illuminaâ€™s GenomeStudio preprocessing.
- `preprocessSWAN`: Subset-quantile within array normalization.
- `preprocessQuantile`: Quantile normalization.
- `preprocessNoob`: Normal-exponential out-of-band background correction.
- `preprocessFunnorm`: Functional normalization.

> __Note__: Find more information about the different preprocessing functions [here](https://www.bioconductor.org/help/course-materials/2015/BioC2015/methylation450k.html#preprocessing-and-normalization).

```{r message=F}
mSet <- preprocessNoob(rgSet)
class(mSet)[1]
```

### Removing low quality probes

Probes with a detection p-value above the cutoff (p=0.01) could be generated by the background signal and may not be reliable enough. It is recommended to remove those sites to avoid biases.

```{r}
keep <- rowSums(p_values < 0.01) == ncol(mSet)
mSet <- mSet[keep,]
```

### Removing probes with known SNPs

```{r warning=F}
gmSet <- dropLociWithSnps(mapToGenome(mSet))
class(gmSet)[1]
```

### Removing cross reactive probes

Cross-reactive probes are sites found to map at different genome locations (which usually involves a autosomal and a sex chromosome). The function `xreactive_probes` excludes the probes found at [Pidsley et al.](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-016-1066-1) and [McCartney et al.](https://www.sciencedirect.com/science/article/pii/S221359601630071X) studies.

```{r}
xreactive_probes <- xreactive_probes(array_type="EPIC")
keep <- !(featureNames(gmSet) %in% xreactive_probes)
gmSet <- gmSet[keep,]
```

### Removing sex chromosomes probes

CpG sites present at the sexual chromosomes (chrX and chrY) can be differently methylated in males and females for many other variables not included in the analysis. In this case, those probes should be removed because the gender of the individuals is not a factor under study. Otherwise, if we were interested in studying the differences in methylation between males and females, we should keep those sites.

```{r warning=F}
ann <- getAnnotation(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)
keep <- !(featureNames(gmSet) %in% ann$Name[ann$chr %in% c("chrX","chrY")])
gmSet <- gmSet[keep,]
```

### Obtaining the beta values

The beta-value is a measurement of the methylation at a CpG site that ranges between 0 and 1 representing a completely unmethylated or methylated site, respectively. It is calculated using the following formula:

$\beta=\frac{M}{M+U+100}$. 

```{r}
beta_values <- getBeta(gmSet)
colnames(beta_values) <- metadata$Sample
head(beta_values[,1:6])
```

## Principal Component Analysis

Principal Component Analysis (PCA) is a dimensionality reduction technique used to reduce a data set with many features into the so-called principal components. Those are a few variables that aim to explain as much variability as possible in order to be able to represent the data in two (or three) dimensions.

### PCA on the most variable sites

Selecting the sites with higher variation across samples may be an approach to reduce the number of inputs for the PCA and speed up the calculation by avoiding the use of "meaningless" features. However, the number of selected variables should be large enough because a small number can reduce the accuracy of the PCA.

```{r}
# selecting the top 100 most variable CpGs
sdv <- apply(beta_values,1, sd)
keep <- names(head(sort(sdv,decreasing=T), 100))
beta_top100 <- beta_values[keep,]

# PCA calculation
pca_res <- prcomp(t(beta_top100), scale=T, center=T)
```

#### Plotting by condition

```{r pca_cond}
autoplot(pca_res, x=1, y=2,data=metadata, colour="Condition")+
  geom_text_repel(aes(label=Sample, color=Condition),hjust=-0.1, vjust=0, show.legend=F, size=3.5)+
  xlim(c(-0.5,0.3)) +
  theme_bw()
```

#### Plotting by cell type

```{r pca_cell}
autoplot(pca_res, x=1, y=2,data=metadata, colour="CellType", shape = "Type")+
  geom_text_repel(aes(label=Sample, color=CellType),hjust=-0.1, vjust=0, show.legend=F, size=3.5)+
  scale_color_brewer(palette="Set1")+ 
  labs(colour="Cell Type") + xlim(c(-0.5,0.3)) +
  theme_bw()
```

## Differential methylation analysis

### Differentially Methylated Positions

The differentially methylated positions (DMPs) are single CpG sites that present statistical differences in the methylation levels when comparing the different groups under study.

#### Finding DMPs

Those positions can be detected using `limma` to build linear models that look for significant differences in the beta values at single probes. In this case, all pairwise comparisons will be performed between the samples grouped by their condition.

```{r results = 'hide'}
# building the design matrix
mutation <- factor(metadata$Condition)
designMat <- model.matrix(~0+mutation, data=metadata)
colnames(designMat) <- levels(mutation)

# building the contrast matrix
contMat <- makeContrasts(Control-E542K, 
                         Control-E545K, 
                         Control-H1047R, 
                         E542K-E545K, 
                         E542K-H1047R, 
                         H1047R-E545K, levels=designMat)

# fitting linear model with limma
fit <- lmFit(beta_values, designMat)
fit2 <- contrasts.fit(fit, contMat)
fit2 <- eBayes(fit2)

summary(decideTests(fit2, p.value=0.01))
```

> __Note__: DMPs are classified in hypomethylated (loss of methylation) or hypermethylated (gain of methylation) sites.

|                   | Hypomethylated | Hypermethylated | TOTAL |
| :---------------- | :------------: | :-------------: | :---: |
| Control vs E542K  | 7              | 1               | 8     |
| Control vs E545K  | 12             | 0               | 12    |
| Control vs H1047R | 17             | 0               | 17    |
| E542K vs E545K    | 3              | 0               | 3     |
| E542K vs H1047R   | 1              | 1               | 2     |
| H1047R vs E545K   | 2              | 0               | 2     |

#### Annotating the DMPs

In the previous step, we obtained the differently methylated sites, but annotating them will provide us specific information relative to where they are located in the genome.

```{r}
contrasts <- colnames(contMat)

# matching beta values with annotation by the probe names
annEPICSub <- ann[match(rownames(beta_values),ann$Name), c(1:4,12:19,22:ncol(ann))]

DMP.list=list() # list to store the DMPs
cg=list() # list to store the names of significant probes

for (i in 1:length(contrasts)){
  # extract the significant DMPs and annotate
  DMP <- topTable(fit2, num=Inf, coef=i, genelist=annEPICSub, p.value=0.01)
  DMP$Contrast <- contrasts[i]
  # saving the results
  DMP.list[[i]] <- DMP
  cg[[i]] <- row.names(DMP)
  # write.csv(DMP_1, file=paste0("results/human/DMP/DMP_", contrasts[i], ".csv"))
}

# merging all the DMPs
DMP_ann <- do.call(rbind, DMP.list)

# classifying DMPs according to its change in methylation
DMP_ann$Type <- "Hypermethylated"
DMP_ann$Type[which(DMP_ann$logFC > 0)] <- "Hypomethylated"

# gene feature annotation
DMP_ann$UCSC_RefGene_Group[which(DMP_ann$UCSC_RefGene_Group == "")] <- "."
DMP_ann$UCSC_RefGene_Group_short <- unlist(lapply(strsplit(DMP_ann$UCSC_RefGene_Group, ";"),'[[', 1))
```

#### DMPs relative to CpG islands

```{r dmp_cgi, warning=F}
DMP_annCGI <- DMP_ann[, c("Contrast", "Relation_to_Island", "Type")]

ggplot(DMP_annCGI, aes(Contrast, fill=Relation_to_Island))+
  facet_wrap(.~Type, scales="free_x")+
  geom_histogram(stat="count", width=0.75)+
  theme_bw()+ 
  theme(axis.text.x=element_text(angle=30, hjust=1, size=8))+
  ylab("Number of DMPs")+ 
  xlab("")
```

#### DMPs relative to gene components

```{r dmp_gene, warning=F}
DMP_Gene_Group <- DMP_ann[,c("Contrast","UCSC_RefGene_Group_short", "Type")]

ggplot(DMP_Gene_Group, aes(Contrast, fill=UCSC_RefGene_Group_short))+
  facet_wrap(.~Type, scales="free_x")+
  geom_histogram(stat="count", width=0.75)+ 
  theme_bw()+ 
  scale_fill_brewer(palette="Set2")+
  theme(axis.text.x=element_text(angle=30, hjust=1, size=8))+
  ylab("Number of DMPs")+
  xlab("")+ 
  labs(fill="UCSC_RefGene")
```

#### Heatmap of the DMPs

```{r dmp_heatmap}
# joining the DMPs with their beta values
DMP_beta <- data.frame(beta_values[unlist(cg), ])
colnames(DMP_beta) <- paste0(metadata$Sample,"_",metadata$Condition)

colors <- colorRampPalette(c("royalblue", "white", "red"))(n=100) # range of colors
heatmap.2(as.matrix(t(unique(DMP_beta))), trace="none", density.inf="none", 
          margins=c(7,10), col=colors, cexRow = 1, lwid = c(5,15), lhei = c(5,15))
```

### Differentially Methylated Regions

Differentially methylated regions (DMRs) rely on the same principle as DMPs. However, instead of looking at single sites, the difference in methylation is compared at regions formed by two or more CpGs.

#### Finding and annotating DMRs

`DMRcate` is a package that allows to find and annotate DMRs from the beta values giving the design and the contrast matrices. It generates a GenomicRanges object containing the coordinates of the DMR and some statistics that support the finding.

```{r warning=F, message=F}
DMR.list <- list()
for(i in 1:length(contrasts)){
  # annotating the CpGs for each contrast + finding significant CpGs
  myAnnotation <- cpg.annotate(object=beta_values, datatype="array", what="Beta", contrasts=T,
                               design=designMat, analysis.type="differential", cont.matrix=contMat, 
                               coef=gsub("_", " - ", as.character(contrasts[i])), arraytype="EPIC")

  if (sum(myAnnotation@ranges@elementMetadata@listData$is.sig)!=0){ # if there are significant CpGs
    # test for DMRs
    DMRs <- dmrcate(myAnnotation, lambda=1000, C=2)
    # extract genomic ranges
    results.ranges <- extractRanges(DMRs)
    # saving the results
    DMR.list[[i]] <- data.frame(Contrast=contrasts[i], results.ranges)
    # write.csv(results.ranges, paste0("results/human/DMR/DMR_", contrasts[i], ".csv"))
  }
}

# showing the found DMRs for the first contrast: control vs E542K
DMR.list[[1]][,c(2:7,14)]
```

#### Plotting DMRs

This package also provides the function `DMR.plot` to plot the DMRs using different tracks based on the `Gviz` package.

```{r dmr, warning=F, message=F}
pal <- brewer.pal(8, "Dark2") # palette

# to colour by mutation (condition)
groups <- pal[1:length(unique(metadata$Condition))]
names(groups) <- levels(factor(metadata$Condition))
cols <- groups[as.character(factor(metadata$Condition))]

# is needed to convert the data frame into a genomic ranges object
DMR.GR <- makeGRangesFromDataFrame(DMR.list[3])

DMR.plot(ranges=DMR.GR, dmr=10, CpGs=beta_values, phen.col=cols, what="Beta", arraytype="EPIC", genome="hg19")
```

> __Note__: Other regions of the genome can be plotted using the [plot_DMR.R](https://github.com/raulsanzr/FDP/blob/main/scripts/plot_DMR.R) script.

## Session information

```{r echo=F}
sessionInfo()
```
