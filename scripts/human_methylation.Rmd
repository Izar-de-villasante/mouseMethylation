---
title: Analysis of human methylation data with R
output: github_document
---

<!-- README.md is generated from human_methylation.Rmd -->

## Required packages

```{r message=F, warning=F}
library(minfi)
library(limma)
library(DMRcate)
library(maxprobes)
library(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)
library(IlluminaHumanMethylationEPICmanifest)
library(readxl)
library(dplyr)
library(ggplot2)
library(ggrepel)
library(ggfortify)
library(gplots)
library(RColorBrewer)
```

## Loading the data

### Methylation data

The data for this study was produced by the Infinium MethylationEPIC BeadChip array designed by Illumina in 2016, which quantifies the methylation levels in more than 850,000 different CpG sites of the human genome.

The following function from [_minfi_](https://bioconductor.org/packages/devel/bioc/vignettes/minfi/inst/doc/minfi.html) can read the IDAT files produced by the array and stores the data in a RGChannelSet object.

```{r warning=F}
rgSet <- read.metharray.exp("data/human/")
class(rgSet)[1]
```

### Metadata

The metadata file contains some relevant information of the samples, such as their name, the mutation they present, or from which cell types were they obtained.

```{r}
metadata <- as.data.frame(read_excel("data/human/PIK3CA_samples_SC.xlsx"))

# renaming and removing redundant information
names(metadata)[1:10] <- c("Sample", "Organism", "Tissue", "Type", "Condition", "Preservation", 
                           "DNA_quantity", "EPIC_ID", "EPIC_position", "EPIC_barcode")
metadata$CellType <- paste(metadata$CellType1, metadata$CellType2, sep="_" )
metadata$CellType <- gsub("thelial","", gsub("_NA","", as.character(metadata$CellType)))
metadata$Condition <- gsub("pik3ca ","", as.character(metadata$Condition))
metadata$Type <- gsub("Vascular malformation", "Mutation", metadata$Type)
metadata <- metadata[,-c(2, 3, 6, 8, 9, 12, 13, 14)]

head(metadata)
```

## Quality control

### QC report

_minfi_ incorporates a function that generates a quality control report of the raw data in PDF format, including plots for the distribution of the beta-values and the intensities at the green and red channels.

```{r eval=F}
# quality control report for the raw data
qcReport(rgSet, pdf="results/human/qcReport.pdf", sampGroups=metadata$Condition, sampNames=metadata$Sample)
```

### Detection p-values

Detection p-values provide a measure of how likely the signal of a probe is different from the background. The following plot includes the mean of the detection p-values of every sample compared to the cutoff (p=0.01).

```{r message=F}
# detection p-values
p_values <- detectionP(rgSet, type = "m+u")

# mean detection p-values
mean_p <- data.frame(p_values=colMeans(p_values), Sample=metadata$Sample)

# plotting the mean detection p-values
ggplot(mean_p, aes(x=Sample, y=p_values, fill=p_values))+
  geom_col()+
  geom_hline(yintercept=0.01, linetype="dashed", color="red")+
  ggtitle("Mean detection p-value per sample")+
  theme_bw()+
  theme(legend.position="none", axis.title.x=element_blank(), axis.title.y=element_blank(), 
        axis.text.x=element_text(angle=30, vjust=1, hjust=1))
```

## Preprocessing

### ssNoob normalization

_minfi_ also offers the possibility to use some different functions to normalize the raw data:

- preprocessRaw: no normalization.
- preprocessIllumina: Illumina’s GenomeStudio preprocessing.
- preprocessSWAN: subset-quantile within array normalization.
- preprocessQuantile: quantile normalization.
- preprocessNoob: normal-exponential out-of-band background correction.
- preprocessFunnorm: functional normalization.

Find more information about the different preprocessing methods [here](https://www.bioconductor.org/help/course-materials/2015/BioC2015/methylation450k.html#preprocessing-and-normalization).

```{r message=F}
mSet <- preprocessNoob(rgSet)
class(mSet)[1]
```

### Removing low quality probes

Probes presenting a detection p-value above the threshold (p=0.01) could be generated by the background signal and may not be reliable.  Those sites should be removed to avoid type I errors.

```{r}
keep <- rowSums(p_values < 0.01) == ncol(mSet)
mSet <- mSet[keep,]
```

### Removing probes with known SNP's

```{r warning=F}
gmSet <- dropLociWithSnps(mapToGenome(mSet))
class(gmSet)[1]
```

### Removing cross reactive probes

We would also be interested in removing the cross-reactive probes, which are sites found to map at different genome locations.

```{r}
xreactive_probes <- xreactive_probes(array_type="EPIC")
keep <- !(featureNames(gmSet) %in% xreactive_probes)
gmSet <- gmSet[keep,]
```

### Removing sex chromosomes probes

As in this analysis gender is not a factor of interest, the CpG sites present at the sexual chromosomes (chrX and chrY) should be removed to avoid possible biases caused by other factors. Otherwise, if we were interested in comparing the methylation between males and females, those must be kept.

```{r warning=F}
ann <- getAnnotation(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)
keep <- !(featureNames(gmSet) %in% ann$Name[ann$chr %in% c("chrX","chrY")])
gmSet <- gmSet[keep,]
```

### Obtaining the beta values

The beta-value is a measurement of the methylation at every CpG site obtained using the following formula: $β=\frac{M}{M+U+100}$. This ratio ranges between 0 and 1 representing a completely unmethylated or methylated site, respectively.

```{r}
beta_values <- getBeta(gmSet)
colnames(beta_values) <- metadata$Sample
head(beta_values[,1:6])
```

## Principal Component Analysis

PCA is a dimensionality reduction technique used to reduce a data set with a large number of features into a few called principal components, which explains as much variance as possible in order to be able to represent the data in two or three dimensions.

### PCA on the most variable sites

Selecting the most variable sites may be a good approach to reduce the number of inputs for the PCA and speed up the calculation without using probes that don't explain differences in the data.

```{r}
# selecting the top 100 most variable CpGs
sdv <- apply(beta_values,1, sd)
keep <- names(head(sort(sdv,decreasing=T), 100))
beta_top100 <- beta_values[keep,]

# PCA
pca_res <- prcomp(t(beta_top100), scale=T, center=T)
```

### Plotting the PCA by condition

```{r}
autoplot(pca_res, x=1, y=2,data=metadata, colour="Condition")+
  geom_text_repel(aes(label=Sample, color=Condition),hjust=-0.1, vjust=0, show.legend=F, size=3.5)+
  xlim(c(-0.5,0.3)) +
  theme_bw()
```

### Plotting the PCA by cell type

```{r}
autoplot(pca_res, x=1, y=2,data=metadata, colour="CellType", shape = "Type")+
  geom_text_repel(aes(label=Sample, color=CellType),hjust=-0.1, vjust=0, show.legend=F, size=3.5)+
  scale_color_brewer(palette = "Set1")+ 
  labs(colour="Cell Type") + xlim(c(-0.5,0.3)) +
  theme_bw()
```

## Differential methylation analysis

### Differentially Methylated Positions

DMPs are individual CpG sites showing different methylation levels across the study groups/samples.

#### Finding the number of DMPs per contrast

Those positions can be detected using [_limma_](https://www.bioconductor.org/packages/devel/bioc/vignettes/limma/inst/doc/usersguide.pdf) to build linear models to find significant differences in the beta values at single probes.

In this case, the samples are grouped according to their condition in the design matrix, and all those groups are compared against all in the contrast matrix.

```{r}
# building the design matrix
mutation <- factor(metadata$Condition)
designMat <- model.matrix(~0+mutation, data=metadata)
colnames(designMat) <- levels(mutation)

# building the contrast matrix
contMat <- makeContrasts(Control-E542K, 
                         Control-E545K, 
                         Control-H1047R, 
                         E542K-E545K, 
                         E542K-H1047R, 
                         H1047R-E545K, levels=designMat)

# fitting linear model with limma
fit <- lmFit(beta_values, designMat)
fit2 <- contrasts.fit(fit, contMat)
fit2 <- eBayes(fit2)

DMP_summary <- summary(decideTests(fit2, p.value=0.01))
rownames(DMP_summary) <- c("Hyper", "NotSig", "Hypo")
colnames(DMP_summary) <- gsub(" - ","_", colnames(DMP_summary))
DMP_summary
```

#### Annotating the DMPs

```{r}
contrasts <- colnames(contMat)

# matching beta values with annotation by the probe names
annEPICSub <- ann[match(rownames(beta_values),ann$Name), c(1:4,12:19,22:ncol(ann))]

DMP.list=list() # list to store the DMPs
cg=list() # list to store the names of significant probes

for (i in 1:length(contrasts)){
  # extract the significant DMPs and annotate
  DMP <- topTable(fit2, num=Inf, coef=i, genelist=annEPICSub, p.value=0.01)
  DMP$Contrast <- contrasts[i]
  # saving the results
  DMP.list[[i]] <- DMP
  cg[[i]] <- row.names(DMP)
  # write.csv(DMP_1, file=paste0("results/human/DMP/DMP_", contrasts[i], ".csv"))
}

# merging all the DMPs
DMP_ann <- do.call(rbind, DMP.list)

# classifying DMPs according to its change in methylation
DMP_ann$Type <- "Hypermethylated"
DMP_ann$Type[which(DMP_ann$logFC > 0)] <- "Hypomethylated"

# gene feature annotation
DMP_ann$UCSC_RefGene_Group[which(DMP_ann$UCSC_RefGene_Group == "")] <- "."
DMP_ann$UCSC_RefGene_Group_short <- unlist(lapply(strsplit(DMP_ann$UCSC_RefGene_Group, ";"),'[[', 1))
```

#### Plotting DMPs in relation with CpG Islands

```{r warning=F}
DMP_annCGI <- DMP_ann[, c("Contrast", "Relation_to_Island", "Type")]

ggplot(DMP_annCGI, aes(Contrast, fill=Relation_to_Island))+
  facet_wrap(.~Type, scales="free_x")+
  geom_histogram(stat="count", width=0.75)+
  theme_bw()+ 
  theme(axis.text.x=element_text(angle=30, hjust=1, size=8))+
  ylab("Number of DMPs")+ 
  xlab("")
```

#### Plotting DMPs in relation with the gene features

```{r warning=F}
DMP_Gene_Group <- DMP_ann[,c("Contrast","UCSC_RefGene_Group_short", "Type")]

ggplot(DMP_Gene_Group, aes(Contrast, fill=UCSC_RefGene_Group_short))+
  facet_wrap(.~Type, scales="free_x")+
  geom_histogram(stat="count", width=0.75)+ 
  theme_bw()+ 
  scale_fill_brewer(palette="Set2")+
  theme(axis.text.x=element_text(angle=30, hjust=1, size=8))+
  ylab("Number of DMPs")+
  xlab("")+ 
  labs(fill="UCSC_RefGene")
```

#### Heatmap

```{r}
# joining the DMPs with their beta values
DMP_beta <- data.frame(beta_values[unlist(cg), ])
colnames(DMP_beta) <- paste0(metadata$Sample,"_",metadata$Condition)

colors <- colorRampPalette(c("royalblue", "white", "red"))(n=100) # range of colors
heatmap.2(as.matrix(t(unique(DMP_beta))), trace="none", density.inf="none", 
          margins=c(7,10), col=colors, cexRow = 1, lwid = c(5,15), lhei = c(5,15))
```

### Differentially Methylated Regions

DMRs are regions formed by CpG sites where the difference in methylation levels across the groups/samples is higher than those outside this region.

#### Finding and annotating the DMRs

[_DMRcate_](https://bioconductor.org/packages/devel/bioc/vignettes/DMRcate/inst/doc/DMRcate.pdf) is a  package that allows the finding and the annotation of DMRs from the beta values. It generates a GenomicRanges object that contains the coordinates of the DMR, some statistics that support the finding, and the symbols of the genes that overlap the DMR (in case there are).

```{r warning=F, message=F}
DMR.list <- list()
for(i in 1:length(contrasts)){
  # annotating the CpGs for each contrast + finding significant CpGs
  myAnnotation <- cpg.annotate(object=beta_values, datatype="array", what="Beta", analysis.type="differential", 
                               design=designMat, contrasts=T, cont.matrix=contMat, 
                               coef=gsub("_", " - ", as.character(contrasts[i])), arraytype="EPIC")

  if (sum(myAnnotation@ranges@elementMetadata@listData$is.sig)!=0){ # if there are significant CpGs
    # test for DMRs
    DMRs <- dmrcate(myAnnotation, lambda=1000, C=2)
    # extract genomic ranges
    results.ranges <- extractRanges(DMRs)
    # saving the results
    DMR.list[[i]] <- data.frame(Contrast=contrasts[i], results.ranges)
    # write.csv(results.ranges, paste0("results/human/DMR/DMR_", contrasts[i], ".csv"))
  }
}

# showing the found DMRs for the first contrast: control vs E542K
head(DMR.list[1])
```

#### Plotting the DMRs

This package also provides a function to plot the DMRs using different tracks with the [_Gviz_](https://bioconductor.org/packages/devel/bioc/vignettes/Gviz/inst/doc/Gviz.html) package, including:

- The genomic coordinates.
- The gene model: showing near or overlapping genes.
- The heatmap of the methylation values.
- The distribution of the mean methylation levels.

```{r warning=F, message=F}
pal <- brewer.pal(8, "Dark2") # palette

# to colour by mutation (condition)
groups <- pal[1:length(unique(metadata$Condition))]
names(groups) <- levels(factor(metadata$Condition))
cols <- groups[as.character(factor(metadata$Condition))]

# is needed to convert the data frame into a genomic ranges object
DMR.GR <- makeGRangesFromDataFrame(DMR.list[3])

DMR.plot(ranges=DMR.GR, dmr=10, CpGs=beta_values, phen.col=cols, what="Beta", arraytype="EPIC", genome="hg19")
```

## Session information

```{r echo=F}
sessionInfo()
```
